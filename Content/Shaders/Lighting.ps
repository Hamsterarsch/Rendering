#include "Types/Light.hlsl"
#include "Types/LightingV2P.hlsl"


ConstantBuffer<VolumeTileGridData> gridData : register(b2);

StructuredBuffer<Light> lights : register(t0);
Buffer<uint> relevantLightIndices : register(t1);//bound to UINT16 formatted buffer
Buffer<LightIndexListInfo> offsetsToRelevantLightChunks : register(t2);


float4 main(LightingV2P IN) : SV_TARGET
{
	float3 viewPos = mul(gridData.inverseProjection, IN.pos).xyz;
		
	uint3 Index = uint3
	(
		pos.xy / (gridData.screenDimensions / gridData.gridDimensions.xy),
		log(1+gridData.fovTermForDepthCompute) / log(viewPos.z / gridData.nearDistance)
	);	

	uint tileIndex = FlattenVolumeTileGridIndex(Index, gridData.gridDimensions.xy);
	LightIndexListInfo indexChunk = offsetsToRelevantLightChunks[tileIndex];
	
	float3 lightAccumulation = float3(0,0,0);
	for(uint iteratedLights = 0; iteratedLights < indexChunk.size; ++iteratedLights)
	{
		//simple dot based accentuation
	
		Light light = lights[ relevantLightIndices[indexChunk.offset+iteratedLights] ];
		float3 lightToFragment = normalize(viewPos.xyz - light.viewPos);
		
		float lightAccentuation = saturate(dot(IN.normal, -lightToFragment))
		
		lightAccumulation += light.color * lightAccentuation;				
	}
	
	return float4(saturate(float3(0.5,0.5,0.5)+lightAccumulation), 1);	

}