{
	`code`: `#include "Types/GlobalBufferData.hlsl"
#include "Types/Light.hlsl"
#include "Types/LightingV2P.hlsl"
#include "Types/VolumeTileGridData.hlsl"
#include "FlattenVolumeTileGridIndex.hlsl"


ConstantBuffer<VolumeTileGridData> gridData : register(b2);

StructuredBuffer<Light> lights : register(t2);
Buffer<uint> relevantLightIndices : register(t3);//bound to UINT16 formatted buffer
StructuredBuffer<LightIndexListInfo> offsetsToRelevantLightChunks : register(t4);


float4 main(LightingV2P IN) : SV_TARGET
{
uint3 Index = uint3
(
IN.pos.xy / (gridData.screenDimensions / gridData.gridDimensions.xy),
log2(IN.viewPos.z - gridData.nearDistance) / log2(1+gridData.fovTermForDepthCompute)
);

uint tileIndex = FlattenVolumeTileGridIndex(Index, gridData.gridDimensions.xy);
LightIndexListInfo indexChunk = offsetsToRelevantLightChunks[tileIndex];

float3 lightAccumulation = float3(0,0,0);
for(uint iteratedLights = 0; iteratedLights < indexChunk.size; ++iteratedLights)
{
//simple dot based accentuation

Light light = lights[ relevantLightIndices[indexChunk.offset+iteratedLights] ];
float3 lightToFragment = IN.worldPos - light.worldPos;

//squared radius falloff
float lightAccentuation = 1-saturate(length(lightToFragment) / light.radius);
lightAccentuation *= lightAccentuation;

//normal shading
lightAccentuation *= saturate(dot(IN.normal, -normalize(lightToFragment)));

lightAccumulation += light.color * lightAccentuation;

}
return float4(saturate(DiffuseColor(IN)+lightAccumulation), 1);

}`,
	`numConstantsSlots`: `0`,
	`numTextureSlots`: `0`
}