{
	`codeLength`: `2135`,
	`code`: `#include "Types/GlobalBufferData.hlsl"#include "Types/Light.hlsl"#include "Types/LightingV2P.hlsl"#include "Types/VolumeTileGridData.hlsl"#include "FlattenVolumeTileGridIndex.hlsl"ConstantBuffer<VolumeTileGridData> gridData : register(b2);StructuredBuffer<Light> lights : register(t0);														   Buffer<uint> relevantLightIndices : register(t1);//bound to UINT16 formatted buffer					   Buffer<LightIndexListInfo> offsetsToRelevantLightChunks : register(t2);								   																									   																									   float4 main(LightingV2P IN) : SV_TARGET																   {																									   	uint3 Index = uint3																				   	(																								   		IN.pos.xy / (gridData.screenDimensions / gridData.gridDimensions.xy),						   		log(1+gridData.fovTermForDepthCompute) / log(IN.worldPos.z / gridData.nearDistance)			   	);																								   																									   	uint tileIndex = FlattenVolumeTileGridIndex(Index, gridData.gridDimensions.xy);					   	LightIndexListInfo indexChunk = offsetsToRelevantLightChunks[tileIndex];						   																									   	float3 lightAccumulation = float3(0,0,0);														   	for(uint iteratedLights = 0; iteratedLights < indexChunk.size; ++iteratedLights)				   	{																								   		//simple dot based accentuation																   																									   		Light light = lights[ relevantLightIndices[indexChunk.offset+iteratedLights] ];				   		float3 lightToFragment = IN.worldPos - light.worldPos;										   																									   		//squared radius falloff																	   		float lightAccentuation = saturate(1 - length(lightToFragment) / light.radius);				   		lightAccentuation *= lightAccentuation;														   																									   		//normal shading																			   		lightAccentuation *= saturate(dot(IN.normal, -normalize(lightToFragment)));					   																									   		lightAccumulation += light.color * lightAccentuation;										   																									   	}																								   	return float4(saturate(float3(0.5,0.5,0.5)+lightAccumulation), 1);								   }`
}